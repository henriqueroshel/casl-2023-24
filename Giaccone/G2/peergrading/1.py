# -*- coding: utf-8 -*-
"""Lab2G2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W1rkp12r63l75u1azHwJ3THTYrM9gWsN
"""

import random
from scipy.stats import t, norm
import math
import numpy as np
import matplotlib.pyplot as plt

arrayCI = np.arange(0.70, 0.99, 0.01)

while True:
    try:
        N = int(input("WRITE THE NUMBER OF SAMPLE YOU WANT TO STUDY: "))
        if N >= 2:
            break
        else:
            print("Please enter a number greater than 2.")
    except ValueError:
        print("Invalid input. Please enter a valid number.")

collector= np.empty(shape=(0,))
for el in range(N):
    x = random.uniform(0, 10)
    collector = np.append(collector, x)

p = f'Collector 1 - Sample:\t '
p+= f'{collector.shape}, {collector.mean():.3f}, {collector.min():.3f}, {collector.max():.3f}'
print(p)

sample_mean = collector.mean()
sample_var = collector.var(ddof=1)

def accuracy(N , CI , sample_mean , sample_var):
  delta=0
  if(N>=30):                                                       # this is for n samples > 30
    z_value = norm.ppf((1 + CI) / 2)                               # to have the value of Z alpha/2
    delta = z_value * (math.sqrt(sample_var) / math.sqrt(N))       # define the range
    interval = ( sample_mean - delta , sample_mean + delta )       # tuple of mean plus minus range
    relative_error = delta / sample_mean
    accuracy = 1- relative_error
    return accuracy , interval

  else:
    interval = t.interval( CI , N-1 , sample_mean, math.sqrt(sample_var/N))     # define the range with t-distribution

    if (interval[0] <= 0 ):                                                     # to manage the interval
      interval = ( 0, interval[1] )                                             # is impossibile to have an interval major of 10 or below to 0 ( negative value)
    if (interval[1] >= 10 ):
      interval =  ( interval[0], 10 )
    if( interval[0] == 0  and interval[1]==10):                                 # the marginal is the maximum if the has this condition [0-10]
      delta=5

    if( interval[0]!=0 and interval[1]==10 ):                                   # we manage the unbalance interval ex. interval [2 -10]
        delta1 = abs(interval[1]-sample_mean)                                 # we compute the interval difference / 2
        delta2 = abs(interval[0]-sample_mean)
        delta = ( delta1 + delta2 )/2
    elif( interval[0]==0 and interval[1]!=10 ):
        delta1 = abs(interval[1]-sample_mean)
        delta2 = abs(interval[0]-sample_mean)
        delta = ( delta1 + delta2 )/2

    if ( interval[0]>0 and interval[1]<10 ):                                    # if we have an interval between 0 - 10
        delta = interval[1]- sample_mean


    relative_error = delta / sample_mean
    if(relative_error>1 or sample_mean<delta or delta==5):                      # to manage each case previously declared
        relative_error=1


    accuracy = 1- relative_error
    return accuracy , interval

collector= np.empty(shape=(0,))
for i in range(2, N + 1):
  acc , interval=  accuracy( i , 0.99, sample_mean , sample_var )
  collector = np.append(collector, acc)
p = f'Collector 2 - Accuracy:\t '
p+= f'{collector.shape}, {collector.mean():.3f}, {collector.min():.3f}, {collector.max():.3f}'
print(p)

axisX1 = []
for i in range(2, N + 1):
    axisX1.append(i)

axisY1 = collector.tolist()

collector_acc= np.empty(shape=(0,))
for i in arrayCI:
  i=round(i, 2)
  acc , interval=  accuracy( N , i , sample_mean , sample_var )
  collector_acc = np.append(collector_acc, acc)

axisY2 = collector_acc.tolist()


while True:     # we want to see the graph for a fixed value of CI
    try:
        CI = round( float(input("WRITE THE LEVEL OF CONFIDENCE YOU WANT TO STUDY: ")) ,2 )
        if 0 < CI <1:
            break
        else:
            print("Please enter a number at between 0 and 1 not included.")
    except ValueError:
        print("Invalid input. Please enter a valid number.")


list_interval = []
for el in axisX1:
  acc , interval=  accuracy( el , CI , sample_mean , sample_var )
  list_interval.append(interval)
  axisY2 = collector_acc.tolist()

axisY3 =  list_interval

y1_values, y2_values = zip(*axisY3)

list_interval1 = []
for el in arrayCI:
  acc , interval=  accuracy( N , el , sample_mean , sample_var )
  list_interval1.append(interval)

y_values =  list_interval1

y3_values, y4_values = zip(*y_values)

fig, axs = plt.subplots(2, 2)

axs[0, 0].plot(axisX1, axisY1)
axs[0, 0].set_title('X = Samples  Y = Accuracy')

axs[0, 1].plot(arrayCI, axisY2)
axs[0, 1].set_title('X = Accuracy  Y = CI')

axs[1, 0].plot(axisX1, y1_values, color='b',  label='Boundary Value')
axs[1, 0].plot(axisX1, y2_values, color='b' )
axs[1, 0].fill_between(axisX1, y1_values, y2_values, color='lightblue', alpha=0.5)
axs[1, 0].set_title('X = Samples  Y = Interval')

axs[1, 1].plot(arrayCI, y3_values, label='Boundary Value' , color="darkorange")
axs[1, 1].plot(arrayCI, y4_values, color='darkorange')
axs[1, 1].fill_between(arrayCI, y3_values, y4_values, color='orange', alpha=0.5)
axs[1, 1].set_title('X = CI  Y = Interval')

plt.tight_layout()  # Optional: adjust the layout for better spacing
plt.show()

fig.savefig('01-graphs.png', format='png')